# Вопросы по проекту

Этот документ содержит список вопросов, возникших на этапе анализа архитектуры и текущей реализации проекта. Ответы на них помогут уточнить требования и избежать потенциальных проблем в будущем.

### 1. Управление доступом
- **Вопрос**: Система доступа сейчас рассчитана на одного администратора (`ADMIN_ID`). Планируется ли в будущем расширение для поддержки нескольких администраторов или ролевой модели?

### 2. Инфраструктура и развертывание
- **Вопрос**: В спецификации указаны несколько вариантов хостинга (Render, Fly.io, VPS). Есть ли уже предпочтения? Выбор повлияет на подготовку скриптов и инструкций по развертыванию.

### 3. Планировщик задач
- **Вопрос**: Спецификация упоминает `asyncio (custom loop)` или `n8n` в качестве планировщика. Текущая реализация (`scheduler.py`) использует `asyncio`. Следует ли придерживаться этого подхода или стоит рассмотреть интеграцию с более мощным внешним инструментом вроде `n8n` или `Celery` для более надежного и гибкого управления фоновыми задачами?

### 4. Конфигурация и переменные окружения
- **Вопрос**: Для полноценной работы бота требуются секретные ключи и ID. Можете ли вы подтвердить или дополнить список необходимых переменных окружения?
  - `TELEGRAM_BOT_TOKEN`: Токен бота Telegram.
  - `ADMIN_ID`: ID администратора бота в Telegram.
  - `OPENROUTER_API_KEY`: Ключ для доступа к API OpenRouter.ai.
- `OPENROUTER_POST_MODEL`: Модель для генерации постов (по умолчанию: deepseek/deepseek-r1:free).
- `OPENROUTER_IMAGE_PROMPT_MODEL`: Модель для создания промптов изображений.
  - `CHANNEL_ID`: ID целевого Telegram-канала для публикации.
  - `VK_API_TOKEN`: Сервисный или пользовательский токен для VK API.
  - `VK_GROUP_ID`: ID группы VK для публикации.

### 5. Управление состояниями (FSM)
- **Вопрос**: В спецификации была указана таблица `user_state` для хранения состояний FSM. Однако `aiogram 3.x` использует собственный механизм `FSMContext`, который по умолчанию хранит данные в оперативной памяти. Это означает, что при перезапуске бота все незавершенные диалоги будут сброшены. Является ли это приемлемым поведением? Если нет, следует ли настроить персистентное хранилище для FSM (например, на основе Redis или SQLite), и нужна ли в таком случае отдельная таблица `user_state`? 